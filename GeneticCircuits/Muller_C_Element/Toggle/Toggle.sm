// File generated by automatic SBML-to-PRISM conversion
// Original SBML file: toggle.xml

ctmc

const int MAX_AMOUNT = 200;

// Compartment size
const double default = 1.0;

// Model parameters
const double kr_f = 0.5; // kr_f
const double kr_r = 1; // kr_r
const double ka_f = 0.0033; // ka_f
const double ka_r = 1; // ka_r
const double kc_f = 0.05; // kc_f
const double kc_r = 1; // kc_r
const double ko_f = 0.033; // ko_f
const double ko_r = 1; // ko_r
const double kao_f = 1; // kao_f
const double kao_r = 1; // kao_r
const double kmdiff_f = 1; // kmdiff_f
const double kmdiff_r = 0.01; // kmdiff_r
const double kd = 0.0075; // kd
const double kecd = 0.005; // kecd
const double nc = 2; // nc
const double nr = 30; // nr
const double ko = 0.05; // ko
const double kb = 0.0001; // kb
const double ng = 2; // ng
const double np = 10; // np
const double ka = 0.25; // ka
const double kecdiff = 1; // kecdiff

// Species AA
const int AA_MAX = MAX_AMOUNT;
module AA
	
	AA : [0..AA_MAX] init 0; // Initial amount 0
	
	
endmodule

// Species B
const int B_MAX = MAX_AMOUNT;
module B
	
	B : [0..B_MAX] init 120; // Initial amount 120
	
	
endmodule

// Species Cout
const int Cout_MAX = MAX_AMOUNT;
module Cout
	
	Cout : [0..Cout_MAX] init 120; // Initial amount 120
	
	// Degradation_Cout
	[Degradation_Cout] Cout > 0 -> (Cout'=Cout-1);
	// Production_P5
	[Production_P5]  Cout <= Cout_MAX-10 -> (Cout'=Cout+10);
	
endmodule

// Species D
const int D_MAX = MAX_AMOUNT;
module D
	
	D : [0..D_MAX] init 0; // Initial amount 0
	
	// Degradation_D
	[Degradation_D] D > 0 -> (D'=D-1);
	// Production_P1
	[Production_P1]  D <= D_MAX-10 -> (D'=D+10);
	
endmodule

// Species EE
const int EE_MAX = MAX_AMOUNT;
module EE
	
	EE : [0..EE_MAX] init 0; // Initial amount 0
	
	// Degradation_EE
	[Degradation_EE] EE > 0 -> (EE'=EE-1);
	// Production_P2
	[Production_P2]  EE <= EE_MAX-10 -> (EE'=EE+10);
	
endmodule

// Species FF
const int FF_MAX = MAX_AMOUNT;
module FF
	
	FF : [0..FF_MAX] init 200; // Initial amount 200
	
	// Degradation_FF
	[Degradation_FF] FF > 0 -> (FF'=FF-1);
	// Production_P8
	[Production_P8]  FF <= FF_MAX-10 -> (FF'=FF+10);
	// Production_P7
	[Production_P7]  FF <= FF_MAX-10 -> (FF'=FF+10);
	
endmodule

// Species XX
const int XX_MAX = MAX_AMOUNT;
module XX
	
	XX : [0..XX_MAX] init 0; // Initial amount 0
	
	// Degradation_XX
	[Degradation_XX] XX > 0 -> (XX'=XX-1);
	// Production_P1
	[Production_P1]  XX <= XX_MAX-10 -> (XX'=XX+10);
	// Production_P2
	[Production_P2]  XX <= XX_MAX-10 -> (XX'=XX+10);
	
endmodule

// Species Y
const int Y_MAX = MAX_AMOUNT;
module Y
	
	Y : [0..Y_MAX] init 200; // Initial amount 200
	
	// Degradation_Y
	[Degradation_Y] Y > 0 -> (Y'=Y-1);
	// Production_P5
	[Production_P5]  Y <= Y_MAX-10 -> (Y'=Y+10);
	// Production_P3
	[Production_P3]  Y <= Y_MAX-10 -> (Y'=Y+10);
	
endmodule

// Species Z
const int Z_MAX = MAX_AMOUNT;
module Z
	
	Z : [0..Z_MAX] init 0; // Initial amount 0
	
	// Degradation_Z
	[Degradation_Z] Z > 0 -> (Z'=Z-1);
	// Production_P4
	[Production_P4]  Z <= Z_MAX-10 -> (Z'=Z+10);
	// Production_P6
	[Production_P6]  Z <= Z_MAX-10 -> (Z'=Z+10);
	
endmodule

// Species P8
const int P8_MAX = MAX_AMOUNT;
module P8
	
	P8 : [0..P8_MAX] init 2; // Initial amount 2
	
	
endmodule

// Species P5
const int P5_MAX = MAX_AMOUNT;
module P5
	
	P5 : [0..P5_MAX] init 2; // Initial amount 2
	
	
endmodule

// Species P4
const int P4_MAX = MAX_AMOUNT;
module P4
	
	P4 : [0..P4_MAX] init 2; // Initial amount 2
	
	
endmodule

// Species P7
const int P7_MAX = MAX_AMOUNT;
module P7
	
	P7 : [0..P7_MAX] init 2; // Initial amount 2
	
	
endmodule

// Species P6
const int P6_MAX = MAX_AMOUNT;
module P6
	
	P6 : [0..P6_MAX] init 2; // Initial amount 2
	
	
endmodule

// Species P1
const int P1_MAX = MAX_AMOUNT;
module P1
	
	P1 : [0..P1_MAX] init 2; // Initial amount 2
	
	
endmodule

// Species P3
const int P3_MAX = MAX_AMOUNT;
module P3
	
	P3 : [0..P3_MAX] init 2; // Initial amount 2
	
	
endmodule

// Species P2
const int P2_MAX = MAX_AMOUNT;
module P2
	
	P2 : [0..P2_MAX] init 2; // Initial amount 2
	
	
endmodule

// Reaction rates
module reaction_rates

	// Degradation_D: D -> 
	[Degradation_D] (kd*D) > 0 -> (kd*D) : true;
	// Degradation_EE: EE -> 
	[Degradation_EE] (kd*EE) > 0 -> (kd*EE) : true;
	// Degradation_FF: FF -> 
	[Degradation_FF] (kd*FF) > 0 -> (kd*FF) : true;
	// Degradation_Cout: Cout -> 
	[Degradation_Cout] (kd*Cout) > 0 -> (kd*Cout) : true;
	// Degradation_Y: Y -> 
	[Degradation_Y] (kd*Y) > 0 -> (kd*Y) : true;
	// Degradation_XX: XX -> 
	[Degradation_XX] (kd*XX) > 0 -> (kd*XX) : true;
	// Degradation_Z: Z -> 
	[Degradation_Z] (kd*Z) > 0 -> (kd*Z) : true;
	// Production_P8:  -> FF
	[Production_P8] (((((P8*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*EE),nc)))) > 0 -> (((((P8*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*EE),nc)))) : true;
	// Production_P5:  -> Y+Cout
	[Production_P5] (((((P5*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*Z),nc)))) > 0 -> (((((P5*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*Z),nc)))) : true;
	// Production_P4:  -> Z
	[Production_P4] (((((P4*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*FF),nc)))) > 0 -> (((((P4*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*FF),nc)))) : true;
	// Production_P7:  -> FF
	[Production_P7] (((((P7*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*D),nc)))) > 0 -> (((((P7*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*D),nc)))) : true;
	// Production_P6:  -> Z
	[Production_P6] (((((P6*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*Y),nc)))) > 0 -> (((((P6*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*Y),nc)))) : true;
	// Production_P1:  -> D+XX
	[Production_P1] (((((P1*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*AA),nc)))) > 0 -> (((((P1*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*AA),nc)))) : true;
	// Production_P3:  -> Y
	[Production_P3] (((((P3*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*XX),nc)))) > 0 -> (((((P3*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*XX),nc)))) : true;
	// Production_P2:  -> EE+XX
	[Production_P2] (((((P2*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*B),nc)))) > 0 -> (((((P2*ko)*ko_f)/ko_r)*nr)/((1+((ko_f/ko_r)*nr))+(func(pow,((kr_f/kr_r)*B),nc)))) : true;

endmodule

// Reward structures (one per species)

// Reward 1: AA
rewards "AA" true : AA; endrewards
// Reward 2: B
rewards "B" true : B; endrewards
// Reward 3: Cout
rewards "Cout" true : Cout; endrewards
// Reward 4: D
rewards "D" true : D; endrewards
// Reward 5: EE
rewards "EE" true : EE; endrewards
// Reward 6: FF
rewards "FF" true : FF; endrewards
// Reward 7: XX
rewards "XX" true : XX; endrewards
// Reward 8: Y
rewards "Y" true : Y; endrewards
// Reward 9: Z
rewards "Z" true : Z; endrewards
// Reward 10: P8
rewards "P8" true : P8; endrewards
// Reward 11: P5
rewards "P5" true : P5; endrewards
// Reward 12: P4
rewards "P4" true : P4; endrewards
// Reward 13: P7
rewards "P7" true : P7; endrewards
// Reward 14: P6
rewards "P6" true : P6; endrewards
// Reward 15: P1
rewards "P1" true : P1; endrewards
// Reward 16: P3
rewards "P3" true : P3; endrewards
// Reward 17: P2
rewards "P2" true : P2; endrewards
