// File generated by automatic SBML-to-PRISM conversion
// Original SBML file: dual_feedback_oscillator.xml

ctmc

const int MAX_AMOUNT = 100;

// Compartment size
const double Cell = 1.0;

// Model parameters
const double ko_r = 1; // ko_r
const double nr = 100; // nr
const double np = 10; // np
const double kr_r = 1; // kr_r
const double ka_f = 0.0033; // ka_f
const double kecdiff = 1; // kecdiff
const double ko = 0.05; // ko
const double kmdiff_f = 1; // kmdiff_f
const double kecd = 0.005; // kecd
const double kc_r = 1; // kc_r
const double kr_f = 0.5; // kr_f
const double ka_r = 1; // ka_r
const double nc = 2; // nc
const double kd = 0.0075; // kd
const double kao_r = 1; // kao_r
const double kb = 0.0001; // kb
const double ng = 20; // ng
const double ka = 0.25; // ka
const double kao_f = 1; // kao_f
const double kmdiff_r = 0.01; // kmdiff_r
const double ko_f = 0.033; // ko_f
const double kc_f = 0.05; // kc_f
const double limit = 0; // limit

// Species AraC
const int AraC_MAX = MAX_AMOUNT;
module AraC
	
	AraC : [0..AraC_MAX] init 0; // Initial amount 0
	
	// Degradation_AraC
	[Degradation_AraC] AraC > 0 -> (AraC'=AraC-1);
	// Production_P2
	[Production_P2]  AraC <= AraC_MAX-10 -> (AraC'=AraC+10);
	
endmodule

// Species LacI
const int LacI_MAX = MAX_AMOUNT;
module LacI
	
	LacI : [0..LacI_MAX] init 0; // Initial amount 0
	
	// Degradation_LacI
	[Degradation_LacI] LacI > 0 -> (LacI'=LacI-1);
	// Production_P1
	[Production_P1]  LacI <= LacI_MAX-10 -> (LacI'=LacI+10);
	
endmodule

// Species P1
const int P1_MAX = MAX_AMOUNT;
module P1
	
	P1 : [0..P1_MAX] init 20; // Initial amount 20
	
	
endmodule

// Species P2
const int P2_MAX = MAX_AMOUNT;
module P2
	
	P2 : [0..P2_MAX] init 20; // Initial amount 20
	
	
endmodule

// Reaction rates
module reaction_rates

	// Degradation_AraC: AraC -> 
	[Degradation_AraC] (kd*AraC) > 0 -> (kd*AraC) : true;
	// Degradation_LacI: LacI -> 
	[Degradation_LacI] (kd*LacI) > 0 -> (kd*LacI) : true;
	// Production_P1:  -> LacI
	[Production_P1] ((P1*((kb*(ko_f/ko_r)*nr)+(ka*(kao_f/kao_r)*nr*(func(pow,((ka_f/ka_r)*AraC),nc)))))/(1+((ko_f/ko_r)*nr)+((kao_f/kao_r)*nr*(func(pow,((ka_f/ka_r)*AraC),nc)))+(func(pow,((kr_f/kr_r)*LacI),nc)))) > 0 -> ((P1*((kb*(ko_f/ko_r)*nr)+(ka*(kao_f/kao_r)*nr*(func(pow,((ka_f/ka_r)*AraC),nc)))))/(1+((ko_f/ko_r)*nr)+((kao_f/kao_r)*nr*(func(pow,((ka_f/ka_r)*AraC),nc)))+(func(pow,((kr_f/kr_r)*LacI),nc)))) : true;
	// Production_P2:  -> AraC
	[Production_P2] ((P2*((kb*(ko_f/ko_r)*nr)+(ka*(kao_f/kao_r)*nr*(func(pow,((ka_f/ka_r)*AraC),nc)))))/(1+((ko_f/ko_r)*nr)+((kao_f/kao_r)*nr*(func(pow,((ka_f/ka_r)*AraC),nc)))+(func(pow,((kr_f/kr_r)*LacI),nc)))) > 0 -> ((P2*((kb*(ko_f/ko_r)*nr)+(ka*(kao_f/kao_r)*nr*(func(pow,((ka_f/ka_r)*AraC),nc)))))/(1+((ko_f/ko_r)*nr)+((kao_f/kao_r)*nr*(func(pow,((ka_f/ka_r)*AraC),nc)))+(func(pow,((kr_f/kr_r)*LacI),nc)))) : true;

endmodule

// Reward structures (one per species)

// Reward 1: AraC
rewards "AraC" true : AraC; endrewards
// Reward 2: LacI
rewards "LacI" true : LacI; endrewards
// Reward 3: P1
rewards "P1" true : P1; endrewards
// Reward 4: P2
rewards "P2" true : P2; endrewards
